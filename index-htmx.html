<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Extraction Field Classifier</title>
    <!-- Alpine.js for state management -->
    <script src="https://unpkg.com/alpinejs@3.13.0/dist/cdn.min.js" defer></script>
    <!-- SheetJS for Excel file handling -->
    <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 75rem;
            margin: 0 auto;
            padding: 1.25rem;
            font-size: 0.875rem;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }
        textarea {
            width: 100%;
            height: 6.25rem;
            padding: 0.625rem;
            font-size: 0.9rem;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 0.3125rem 0.375rem;
            text-align: left;
            font-size: 0.6875rem;
        }
        th {
            background-color: #f2f2f2;
        }
        .buttons {
            display: flex;
            gap: 0.625rem;
        }
        button {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .hidden {
            display: none;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 1.25rem;
            border-radius: 0.3125rem;
            width: 80%;
            max-width: 50rem;
            max-height: 80vh;
            overflow-y: auto;
        }
        .search-filters {
            display: flex;
            gap: 0.625rem;
            margin-bottom: 0.9375rem;
        }
        .search-filters input, .search-filters select {
            flex: 1;
            padding: 0.375rem 0.5rem;
            font-size: 0.9rem;
        }
        .search-results {
            max-height: 25rem;
            overflow-y: auto;
        }
        .action-buttons {
            display: flex;
            gap: 0.3125rem;
        }
        .action-buttons button {
            padding: 0.1875rem 0.5rem;
            font-size: 0.6875rem;
        }
        button.active {
            background-color: #4CAF50;
            color: white;
        }
        .search-message {
            padding: 0.5rem;
            color: #666;
            text-align: center;
            font-style: italic;
            font-size: 0.9rem;
        }
        .file-inputs {
            display: flex;
            flex-direction: column;
            gap: 0.625rem;
        }
        .file-input-row {
            display: flex;
            align-items: center;
            gap: 0.625rem;
        }
        .file-input-row button {
            padding: 0.375rem 0.625rem;
        }
        .status-icon {
            font-size: 1.2rem;
            cursor: help;
            position: relative;
            display: inline-block;
        }
        .status-icon .tooltip {
            visibility: hidden;
            width: 12.5rem;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 0.375rem;
            padding: 0.3125rem;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -6.25rem;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
        }
        .status-icon:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        
        /* Media queries based on viewport width rather than DPI */
        @media screen and (min-width: 768px) {
            html {
                font-size: 16px; /* Base font size for medium screens */
            }
        }
        
        @media screen and (min-width: 1200px) {
            html {
                font-size: 18px; /* Base font size for large screens */
            }
        }
        
        @media screen and (min-width: 1600px) {
            html {
                font-size: 20px; /* Base font size for extra large screens */
            }
        }
    </style>
</head>
<body>
    <div class="container" x-data="app()">
        <h1>Data Extraction Field Classifier</h1>
        
        <div>
            <h2>Step 1: Load Metadata Files</h2>
            <div class="file-inputs">
                <div class="file-input-row">
                    <button @click="loadDefaultMetadata()">Load Default Metadata</button>
                    <span class="status-icon" x-show="metadataStatus">
                        <span x-html="metadataStatus.includes('successfully') ? '✅' : '❌'"></span>
                        <span class="tooltip" x-text="metadataStatus"></span>
                    </span>
                </div>
                <div class="file-input-row">
                    <label>Or upload custom Metadata Excel:</label>
                    <input type="file" id="metadata-file" accept=".xlsx,.xls" @change="loadMetadata($event)">
                </div>
                
                <div class="file-input-row" style="margin-top: 10px;">
                    <button @click="loadDefaultAlreadyRequestedMetadata()">Load Default Already Requested Metadata</button>
                    <span class="status-icon" x-show="alreadyRequestedStatus">
                        <span x-html="alreadyRequestedStatus.includes('successfully') ? '✅' : '❌'"></span>
                        <span class="tooltip" x-text="alreadyRequestedStatus"></span>
                    </span>
                </div>
                <div class="file-input-row">
                    <label>Or upload custom Already Requested Metadata Excel:</label>
                    <input type="file" id="already-requested-file" accept=".xlsx,.xls" @change="loadAlreadyRequestedMetadata($event)">
                </div>
            </div>
        </div>
        
        <div>
            <h2>Step 2: Enter Field Names</h2>
            <p>Enter one field name per line:</p>
            <textarea id="field-names" placeholder="id&#10;name&#10;credit_score" x-model="fieldNamesText"></textarea>
            <div class="buttons">
                <button @click="processFields()">Process Fields</button>
            </div>
        </div>
        
        <div id="results-section" x-show="showResults">
            <h2>Results</h2>
            <table id="results-table">
                <thead>
                    <tr>
                        <th>Source</th>
                        <th>Source Field</th>
                        <th>Field Name</th>
                        <th>Classification</th>
                        <th>PI</th>
                        <th>PCI</th>
                        <th>Treatment</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="results-body">
                    <template x-for="(result, index) in results" :key="index">
                        <tr :data-field-name="result.fieldName">
                            <td>
                                <template x-if="result.noMatch">
                                    <span>-</span>
                                </template>
                                <template x-if="!result.noMatch">
                                    <span x-text="result.currentField.source"></span>
                                </template>
                            </td>
                            <td>
                                <template x-if="result.noMatch">
                                    <span>-</span>
                                </template>
                                <template x-if="!result.noMatch">
                                    <span x-text="result.currentField.name"></span>
                                </template>
                            </td>
                            <td x-text="result.fieldName"></td>
                            <td x-text="result.noMatch ? 'No matching field found' : result.currentField.classification" :colspan="result.noMatch ? 4 : 1"></td>
                            <td x-text="result.noMatch ? '' : result.currentField.pi" x-show="!result.noMatch"></td>
                            <td x-text="result.noMatch ? '' : result.currentField.pci" x-show="!result.noMatch"></td>
                            <td x-text="result.noMatch ? '' : result.currentField.treatment" x-show="!result.noMatch"></td>
                            <td>
                                <div class="action-buttons">
                                    <button @click="setAutoMode(index)" :class="{ 'active': result.mode === 'auto' }">Auto</button>
                                    <button @click="openSearch(index)" :class="{ 'active': result.mode === 'manual' }">Search</button>
                                </div>
                            </td>
                        </tr>
                    </template>
                </tbody>
            </table>
            <div class="buttons">
                <button @click="exportResults()">Export Results</button>
                <button @click="copyAsTable()">Copy as Table</button>
            </div>
        </div>
        
        <!-- Search Modal -->
        <div class="modal" x-show="showSearchModal" @click.self="closeSearch()">
            <div class="modal-content">
                <h3>Search Fields</h3>
                <div class="search-filters">
                    <input type="text" placeholder="Field name (min 2 chars)" x-model="searchFieldName" @input="updateSearchResults()">
                    <input type="text" placeholder="Source (min 4 chars)" x-model="searchSource" @input="updateSearchResults()">
                    <select x-model="searchLimit" @change="updateSearchResults()">
                        <option value="20">Limit: 20</option>
                        <option value="100">Limit: 100</option>
                        <option value="1000">Limit: 1000</option>
                    </select>
                </div>
                <div class="search-results">
                    <template x-if="!canSearch">
                        <div class="search-message">Enter at least 2 characters in Field name or 4 characters in Source to search</div>
                    </template>
                    <template x-if="canSearch && filteredSearchResults.length === 0">
                        <div class="search-message">No matching fields found</div>
                    </template>
                    <template x-if="filteredSearchResults.length > 0">
                        <table>
                            <thead>
                                <tr>
                                    <th>Source</th>
                                    <th>Field Name</th>
                                    <th>Classification</th>
                                    <th>PI</th>
                                    <th>PCI</th>
                                    <th>Treatment</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="(field, index) in filteredSearchResults" :key="index">
                                    <tr>
                                        <td x-text="field.source"></td>
                                        <td x-text="field.name"></td>
                                        <td x-text="field.classification"></td>
                                        <td x-text="field.pi"></td>
                                        <td x-text="field.pci"></td>
                                        <td x-text="field.treatment"></td>
                                        <td>
                                            <button @click="selectField(field)">Select</button>
                                        </td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </template>
                </div>
                <div class="buttons" style="margin-top: 15px;">
                    <button @click="closeSearch()">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        function app() {
            return {
                metadataData: [],
                alreadyRequestedData: [],
                fieldNamesText: '',
                results: [],
                showResults: false,
                showSearchModal: false,
                searchFieldName: '',
                searchSource: '',
                searchLimit: '20',
                currentSearchIndex: null,
                filteredSearchResults: [],
                metadataStatus: '',
                alreadyRequestedStatus: '',
                originalResults: [], // Store original auto-detected results
                
                get canSearch() {
                    return this.searchFieldName.length >= 2 || this.searchSource.length >= 4;
                },
                
                init() {
                    // Load default metadata files on page load
                    // this.loadDefaultMetadata();
                    // this.loadDefaultAlreadyRequestedMetadata();
                },
                
                loadDefaultMetadata() {
                    this.metadataStatus = 'Loading...';
                    fetch('src/metadata.xlsx')
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Network response was not ok');
                            }
                            return response.arrayBuffer();
                        })
                        .then(buffer => {
                            const data = new Uint8Array(buffer);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const worksheet = workbook.Sheets['metadata']; // workbook.SheetNames[0]
                            const jsonData = XLSX.utils.sheet_to_json(worksheet);
                            this.metadataData = jsonData;
                            this.metadataStatus = 'Default metadata loaded successfully!';
                        })
                        .catch(error => {
                            console.error('Error loading default metadata:', error);
                            this.metadataStatus = 'Error loading default metadata. Please upload manually.';
                        });
                },
                
                loadDefaultAlreadyRequestedMetadata() {
                    this.alreadyRequestedStatus = 'Loading...';
                    fetch('src/already_requested_metadata.xlsx')
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Network response was not ok');
                            }
                            return response.arrayBuffer();
                        })
                        .then(buffer => {
                            const data = new Uint8Array(buffer);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const worksheet = workbook.Sheets['data'];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet);
                            this.alreadyRequestedData = jsonData;
                            this.alreadyRequestedStatus = 'Default already requested metadata loaded successfully!';
                        })
                        .catch(error => {
                            console.error('Error loading default already requested metadata:', error);
                            this.alreadyRequestedStatus = 'Error loading default already requested metadata. Please upload manually.';
                        });
                },
                
                updateSearchResults() {
                    if (!this.canSearch) {
                        this.filteredSearchResults = [];
                        return;
                    }
                    
                    // Combine both data sources
                    const allFields = [
                        ...this.alreadyRequestedData.map(item => ({
                            ...item,
                            source: item.report || 'Unknown Report',
                            name: item.name
                        })),
                        ...this.metadataData.filter(item => item.object_type === 'field').map(item => {
                            const pathParts = item.path.split('/');
                            const tableName = pathParts[pathParts.length - 2];
                            return {
                                ...item,
                                source: tableName,
                                name: item.name
                            };
                        })
                    ];
                    
                    // Apply filters
                    this.filteredSearchResults = allFields.filter(field => {
                        const nameMatch = this.searchFieldName.length < 2 || 
                            field.name.toLowerCase().includes(this.searchFieldName.toLowerCase());
                        const sourceMatch = this.searchSource.length < 4 || 
                            field.source.toLowerCase().includes(this.searchSource.toLowerCase());
                        return nameMatch && sourceMatch;
                    }).slice(0, parseInt(this.searchLimit)); // Apply limit
                },
                
                loadMetadata(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const worksheet = workbook.Sheets['metadata'];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet);
                        this.metadataData = jsonData;
                        this.metadataStatus = 'Custom metadata loaded successfully!';
                    };
                    reader.readAsArrayBuffer(file);
                },
                
                loadAlreadyRequestedMetadata(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const worksheet = workbook.Sheets['data'];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet);
                        this.alreadyRequestedData = jsonData;
                        this.alreadyRequestedStatus = 'Custom already requested metadata loaded successfully!';
                    };
                    reader.readAsArrayBuffer(file);
                },
                
                parseCSV(content) {
                    const lines = content.split('\n');
                    const headers = lines[0].split(',');
                    
                    return lines.slice(1)
                        .filter(line => line.trim() !== '')
                        .map(line => {
                            const values = line.split(',');
                            const obj = {};
                            
                            headers.forEach((header, i) => {
                                obj[header.trim()] = values[i] ? values[i].trim() : '';
                            });
                            
                            return obj;
                        });
                },
                
                processFields() {
                    if (this.metadataData.length === 0) {
                        alert('Please load metadata CSV first!');
                        return;
                    }
                    
                    const fieldNames = this.fieldNamesText.split('\n').filter(name => name.trim() !== '');
                    
                    if (fieldNames.length === 0) {
                        alert('Please enter at least one field name!');
                        return;
                    }
                    
                    this.results = fieldNames.map(fieldName => {
                        // First check in already requested data (higher priority)
                        const alreadyRequestedMatches = this.alreadyRequestedData.filter(item => 
                            item.name === fieldName.trim()
                        );
                        
                        if (alreadyRequestedMatches.length > 0) {
                            // Add source information
                            const enhancedMatches = alreadyRequestedMatches.map(match => ({
                                ...match,
                                source: match.report || 'Unknown Report',
                                name: match.name
                            }));
                            
                            return {
                                fieldName,
                                noMatch: false,
                                matchingFields: enhancedMatches,
                                currentField: enhancedMatches[0],
                                mode: 'auto'
                            };
                        }
                        
                        // Then check in metadata
                        const metadataMatches = this.metadataData.filter(item => 
                            item.object_type === 'field' && item.name === fieldName.trim()
                        );
                        
                        if (metadataMatches.length > 0) {
                            // Add source information
                            const enhancedMatches = metadataMatches.map(match => {
                                const pathParts = match.path.split('/');
                                const tableName = pathParts[pathParts.length - 2];
                                return {
                                    ...match,
                                    source: tableName,
                                    name: match.name
                                };
                            });
                            
                            return {
                                fieldName,
                                noMatch: false,
                                matchingFields: enhancedMatches,
                                currentField: enhancedMatches[0],
                                mode: 'auto'
                            };
                        }
                        
                        // No match found
                        return {
                            fieldName,
                            noMatch: true,
                            mode: 'auto'
                        };
                    });
                    
                    // Store a deep copy of the original results for Auto mode
                    this.originalResults = JSON.parse(JSON.stringify(this.results));
                    
                    this.showResults = true;
                },
                
                setAutoMode(index) {
                    // Restore the original auto-detected result
                    if (this.originalResults[index]) {
                        this.results[index] = JSON.parse(JSON.stringify(this.originalResults[index]));
                        this.results[index].mode = 'auto';
                    }
                },
                
                openSearch(index) {
                    this.currentSearchIndex = index;
                    this.searchFieldName = this.results[index].fieldName;
                    this.searchSource = '';
                    this.searchLimit = '20';
                    this.showSearchModal = true;
                    this.updateSearchResults();
                },
                
                closeSearch() {
                    this.showSearchModal = false;
                    this.currentSearchIndex = null;
                    this.searchFieldName = '';
                    this.searchSource = '';
                    this.filteredSearchResults = [];
                },
                
                selectField(field) {
                    if (this.currentSearchIndex !== null) {
                        this.results[this.currentSearchIndex].noMatch = false;
                        this.results[this.currentSearchIndex].currentField = field;
                        this.results[this.currentSearchIndex].mode = 'manual';
                        this.closeSearch();
                    }
                },
                
                exportResults() {
                    if (this.results.length === 0) {
                        alert('No results to export!');
                        return;
                    }
                    
                    let csvContent = 'object_type,name,path,classification,pi,pci,treatment\n';
                    
                    this.results.forEach(result => {
                        if (result.noMatch) return;
                        
                        // Use the original field name for export, but keep all other data from the selected field
                        csvContent += `field,${result.fieldName},${result.currentField.path || ''},${result.currentField.classification},${result.currentField.pi},${result.currentField.pci},${result.currentField.treatment}\n`;
                    });
                    
                    this.downloadCSV(csvContent, 'classified_fields.csv');
                },
                
                copyAsTable() {
                    if (this.results.length === 0) {
                        alert('No results to copy!');
                        return;
                    }
                    
                    // Create a table with the specified columns
                    let tableContent = '';
                    
                    // Add each row
                    this.results.forEach(result => {
                        if (result.noMatch) {
                            tableContent += `${result.fieldName}\tNo matching field found\t\t\t\n`;
                        } else {
                            tableContent += `${result.fieldName}\t${result.currentField.classification}\t${result.currentField.pi}\t${result.currentField.pci}\t${result.currentField.treatment}\n`;
                        }
                    });
                    
                    // Copy to clipboard
                    this.copyToClipboard(tableContent);
                    alert('Table copied to clipboard!');
                },
                
                copyToClipboard(text) {
                    // Create a temporary textarea element
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    document.body.appendChild(textarea);
                    
                    // Select and copy the text
                    textarea.select();
                    document.execCommand('copy');
                    
                    // Remove the temporary element
                    document.body.removeChild(textarea);
                },
                
                downloadCSV(content, filename) {
                    const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    
                    const link = document.createElement('a');
                    link.setAttribute('href', url);
                    link.setAttribute('download', filename);
                    link.style.visibility = 'hidden';
                    
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
            };
        }
    </script>
</body>
</html>