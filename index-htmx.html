<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Extraction Field Classifier</title>
    <!-- Alpine.js for state management -->
    <script src="https://unpkg.com/alpinejs@3.13.0/dist/cdn.min.js" defer></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .buttons {
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 15px;
            cursor: pointer;
        }
        .hidden {
            display: none;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .search-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .search-filters input {
            flex: 1;
            padding: 8px;
        }
        .search-results {
            max-height: 400px;
            overflow-y: auto;
        }
        .action-buttons {
            display: flex;
            gap: 5px;
        }
        .action-buttons button {
            padding: 5px 10px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container" x-data="app()">
        <h1>Data Extraction Field Classifier</h1>
        
        <div>
            <h2>Step 1: Load Metadata Files</h2>
            <div>
                <label>Metadata CSV:</label>
                <input type="file" id="metadata-file" accept=".csv" @change="loadMetadata($event)">
            </div>
            <div style="margin-top: 10px;">
                <label>Already Requested Metadata CSV:</label>
                <input type="file" id="already-requested-file" accept=".csv" @change="loadAlreadyRequestedMetadata($event)">
            </div>
        </div>
        
        <div>
            <h2>Step 2: Enter Field Names</h2>
            <p>Enter one field name per line:</p>
            <textarea id="field-names" placeholder="id&#10;name&#10;credit_score" x-model="fieldNamesText"></textarea>
            <div class="buttons">
                <button @click="processFields()">Process Fields</button>
            </div>
        </div>
        
        <div id="results-section" x-show="showResults">
            <h2>Results</h2>
            <table id="results-table">
                <thead>
                    <tr>
                        <th>Source</th>
                        <th>Field Name</th>
                        <th>Path</th>
                        <th>Classification</th>
                        <th>PI</th>
                        <th>PCI</th>
                        <th>Treatment</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="results-body">
                    <template x-for="(result, index) in results" :key="index">
                        <tr :data-field-name="result.fieldName">
                            <td>
                                <template x-if="result.noMatch">
                                    <span>-</span>
                                </template>
                                <template x-if="!result.noMatch">
                                    <span x-text="result.currentField.source"></span>
                                </template>
                            </td>
                            <td x-text="result.fieldName"></td>
                            <td x-text="result.noMatch ? 'No matching field found' : result.currentField.path" :colspan="result.noMatch ? 5 : 1"></td>
                            <td x-text="result.noMatch ? '' : result.currentField.classification" x-show="!result.noMatch"></td>
                            <td x-text="result.noMatch ? '' : result.currentField.pi" x-show="!result.noMatch"></td>
                            <td x-text="result.noMatch ? '' : result.currentField.pci" x-show="!result.noMatch"></td>
                            <td x-text="result.noMatch ? '' : result.currentField.treatment" x-show="!result.noMatch"></td>
                            <td>
                                <div class="action-buttons">
                                    <button @click="setAutoMode(index)" :class="{ 'active': result.mode === 'auto' }">Auto</button>
                                    <button @click="openSearch(index)">Search</button>
                                </div>
                            </td>
                        </tr>
                    </template>
                </tbody>
            </table>
            <div class="buttons">
                <button @click="exportResults()">Export Results</button>
            </div>
        </div>
        
        <!-- Search Modal -->
        <div class="modal" x-show="showSearchModal" @click.self="closeSearch()">
            <div class="modal-content">
                <h3>Search Fields</h3>
                <div class="search-filters">
                    <input type="text" placeholder="Field name" x-model="searchFieldName">
                    <input type="text" placeholder="Source" x-model="searchSource">
                </div>
                <div class="search-results">
                    <table>
                        <thead>
                            <tr>
                                <th>Source</th>
                                <th>Field Name</th>
                                <th>Path</th>
                                <th>Classification</th>
                                <th>PI</th>
                                <th>PCI</th>
                                <th>Treatment</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            <template x-for="(field, index) in filteredSearchResults" :key="index">
                                <tr>
                                    <td x-text="field.source"></td>
                                    <td x-text="field.name"></td>
                                    <td x-text="field.path"></td>
                                    <td x-text="field.classification"></td>
                                    <td x-text="field.pi"></td>
                                    <td x-text="field.pci"></td>
                                    <td x-text="field.treatment"></td>
                                    <td>
                                        <button @click="selectField(field)">Select</button>
                                    </td>
                                </tr>
                            </template>
                        </tbody>
                    </table>
                </div>
                <div class="buttons" style="margin-top: 15px;">
                    <button @click="closeSearch()">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        function app() {
            return {
                metadataData: [],
                alreadyRequestedData: [],
                fieldNamesText: '',
                results: [],
                showResults: false,
                showSearchModal: false,
                searchFieldName: '',
                searchSource: '',
                currentSearchIndex: null,
                
                get filteredSearchResults() {
                    // Combine both data sources
                    const allFields = [
                        ...this.alreadyRequestedData.map(item => ({
                            ...item,
                            source: item.report || 'Unknown Report'
                        })),
                        ...this.metadataData.filter(item => item.object_type === 'field').map(item => {
                            const pathParts = item.path.split('/');
                            const tableName = pathParts[pathParts.length - 2];
                            return {
                                ...item,
                                source: tableName
                            };
                        })
                    ];
                    
                    // Apply filters
                    return allFields.filter(field => {
                        const nameMatch = !this.searchFieldName || 
                            field.name.toLowerCase().includes(this.searchFieldName.toLowerCase());
                        const sourceMatch = !this.searchSource || 
                            field.source.toLowerCase().includes(this.searchSource.toLowerCase());
                        return nameMatch && sourceMatch;
                    }).slice(0, 10); // Limit to 10 results
                },
                
                loadMetadata(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;
                        this.metadataData = this.parseCSV(content);
                        alert('Metadata loaded successfully!');
                    };
                    reader.readAsText(file);
                },
                
                loadAlreadyRequestedMetadata(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;
                        this.alreadyRequestedData = this.parseCSV(content);
                        alert('Already Requested Metadata loaded successfully!');
                    };
                    reader.readAsText(file);
                },
                
                parseCSV(content) {
                    const lines = content.split('\n');
                    const headers = lines[0].split(',');
                    
                    return lines.slice(1)
                        .filter(line => line.trim() !== '')
                        .map(line => {
                            const values = line.split(',');
                            const obj = {};
                            
                            headers.forEach((header, i) => {
                                obj[header.trim()] = values[i] ? values[i].trim() : '';
                            });
                            
                            return obj;
                        });
                },
                
                processFields() {
                    if (this.metadataData.length === 0) {
                        alert('Please load metadata CSV first!');
                        return;
                    }
                    
                    const fieldNames = this.fieldNamesText.split('\n').filter(name => name.trim() !== '');
                    
                    if (fieldNames.length === 0) {
                        alert('Please enter at least one field name!');
                        return;
                    }
                    
                    this.results = fieldNames.map(fieldName => {
                        // First check in already requested data (higher priority)
                        const alreadyRequestedMatches = this.alreadyRequestedData.filter(item => 
                            item.name === fieldName.trim()
                        );
                        
                        if (alreadyRequestedMatches.length > 0) {
                            // Add source information
                            const enhancedMatches = alreadyRequestedMatches.map(match => ({
                                ...match,
                                path: match.path || `report/${match.report}/${match.name}`,
                                source: match.report || 'Unknown Report'
                            }));
                            
                            return {
                                fieldName,
                                noMatch: false,
                                matchingFields: enhancedMatches,
                                currentField: enhancedMatches[0],
                                mode: 'auto'
                            };
                        }
                        
                        // Then check in metadata
                        const metadataMatches = this.metadataData.filter(item => 
                            item.object_type === 'field' && item.name === fieldName.trim()
                        );
                        
                        if (metadataMatches.length > 0) {
                            // Add source information
                            const enhancedMatches = metadataMatches.map(match => {
                                const pathParts = match.path.split('/');
                                const tableName = pathParts[pathParts.length - 2];
                                return {
                                    ...match,
                                    source: tableName
                                };
                            });
                            
                            return {
                                fieldName,
                                noMatch: false,
                                matchingFields: enhancedMatches,
                                currentField: enhancedMatches[0],
                                mode: 'auto'
                            };
                        }
                        
                        // No match found
                        return {
                            fieldName,
                            noMatch: true,
                            mode: 'auto'
                        };
                    });
                    
                    this.showResults = true;
                },
                
                setAutoMode(index) {
                    this.results[index].mode = 'auto';
                    // Reset to default matching logic
                    if (!this.results[index].noMatch && this.results[index].matchingFields.length > 0) {
                        this.results[index].currentField = this.results[index].matchingFields[0];
                    }
                },
                
                openSearch(index) {
                    this.currentSearchIndex = index;
                    this.searchFieldName = this.results[index].fieldName;
                    this.searchSource = '';
                    this.showSearchModal = true;
                },
                
                closeSearch() {
                    this.showSearchModal = false;
                    this.currentSearchIndex = null;
                    this.searchFieldName = '';
                    this.searchSource = '';
                },
                
                selectField(field) {
                    if (this.currentSearchIndex !== null) {
                        this.results[this.currentSearchIndex].noMatch = false;
                        this.results[this.currentSearchIndex].currentField = field;
                        this.results[this.currentSearchIndex].mode = 'manual';
                        this.closeSearch();
                    }
                },
                
                exportResults() {
                    if (this.results.length === 0) {
                        alert('No results to export!');
                        return;
                    }
                    
                    let csvContent = 'object_type,name,path,classification,pi,pci,treatment\n';
                    
                    this.results.forEach(result => {
                        if (result.noMatch) return;
                        
                        csvContent += `field,${result.fieldName},${result.currentField.path},${result.currentField.classification},${result.currentField.pi},${result.currentField.pci},${result.currentField.treatment}\n`;
                    });
                    
                    this.downloadCSV(csvContent, 'classified_fields.csv');
                },
                
                downloadCSV(content, filename) {
                    const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    
                    const link = document.createElement('a');
                    link.setAttribute('href', url);
                    link.setAttribute('download', filename);
                    link.style.visibility = 'hidden';
                    
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
            };
        }
    </script>
</body>
</html>