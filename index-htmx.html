<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Extraction Field Classifier</title>
    <!-- Alpine.js for state management -->
    <script src="https://unpkg.com/alpinejs@3.13.0/dist/cdn.min.js" defer></script>
    <!-- SheetJS for Excel file handling -->
    <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 75rem;
            margin: 0 auto;
            padding: 1.25rem;
            font-size: 0.875rem;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }
        textarea {
            width: 100%;
            height: 6.25rem;
            padding: 0.625rem;
            font-size: 0.9rem;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 0.3125rem 0.375rem;
            text-align: left;
            font-size: 0.6875rem;
        }
        th {
            background-color: #f2f2f2;
        }
        .buttons {
            display: flex;
            gap: 0.625rem;
        }
        button {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .hidden {
            display: none;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 1.25rem;
            border-radius: 0.3125rem;
            width: 80%;
            max-width: 50rem;
            max-height: 80vh;
            overflow-y: auto;
        }
        .search-filters {
            display: flex;
            gap: 0.625rem;
            margin-bottom: 0.9375rem;
        }
        .search-filters input, .search-filters select {
            flex: 1;
            padding: 0.375rem 0.5rem;
            font-size: 0.9rem;
        }
        .search-results {
            max-height: 25rem;
            overflow-y: auto;
        }
        .action-buttons {
            display: flex;
            gap: 0.3125rem;
        }
        .action-buttons button {
            padding: 0.1875rem 0.5rem;
            font-size: 0.6875rem;
        }
        button.active {
            background-color: #4CAF50;
            color: white;
        }
        .search-message {
            padding: 0.5rem;
            color: #666;
            text-align: center;
            font-style: italic;
            font-size: 0.9rem;
        }
        .file-inputs {
            display: flex;
            flex-direction: column;
            gap: 0.625rem;
        }
        .file-input-row {
            display: flex;
            align-items: center;
            gap: 0.625rem;
        }
        .file-input-row button {
            padding: 0.375rem 0.625rem;
        }
        .status-icon {
            font-size: 1.2rem;
            cursor: help;
            position: relative;
            display: inline-block;
        }
        .status-icon .tooltip {
            visibility: hidden;
            width: 12.5rem;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 0.375rem;
            padding: 0.3125rem;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -6.25rem;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
        }
        .status-icon:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        
        /* Media queries based on viewport width rather than DPI */
        @media screen and (min-width: 768px) {
            html {
                font-size: 16px; /* Base font size for medium screens */
            }
        }
        
        @media screen and (min-width: 1200px) {
            html {
                font-size: 18px; /* Base font size for large screens */
            }
        }
        
        @media screen and (min-width: 1600px) {
            html {
                font-size: 20px; /* Base font size for extra large screens */
            }
        }
        .tooltip-container {
            position: relative;
            display: inline-block;
        }
        
        .tooltip-container .tooltip {
            visibility: hidden;
            width: 250px;
            background-color: #555;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1001;
            bottom: 125%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.3s;
            white-space: pre-line; /* Preserve line breaks */
            font-size: 0.8rem;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .tooltip-container:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        
        /* Add a small arrow to the tooltip */
        .tooltip-container .tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #555 transparent transparent transparent;
        }
    </style>
</head>
<body>
    <div class="container" x-data="app()">
        <h1>Data Extraction Field Classifier</h1>
        
        <div>
            <h2>Step 1: Load Metadata Files</h2>
            <div class="file-inputs">
                <div class="file-input-row">
                    <button @click="loadDefaultMetadata()">Load Default Metadata</button>
                    <span class="status-icon" x-show="metadataStatus">
                        <span x-html="metadataStatus.includes('successfully') ? '✅' : '❌'"></span>
                        <span class="tooltip" x-text="metadataStatus"></span>
                    </span>
                </div>
                <div class="file-input-row">
                    <label>Or upload custom Metadata Excel:</label>
                    <input type="file" id="metadata-file" accept=".xlsx,.xls" @change="loadMetadata($event)">
                </div>
                
                <div class="file-input-row" style="margin-top: 10px;">
                    <button @click="loadDefaultAlreadyRequestedMetadata()">Load Default Already Requested Metadata</button>
                    <span class="status-icon" x-show="alreadyRequestedStatus">
                        <span x-html="alreadyRequestedStatus.includes('successfully') ? '✅' : '❌'"></span>
                        <span class="tooltip" x-text="alreadyRequestedStatus"></span>
                    </span>
                </div>
                <div class="file-input-row">
                    <label>Or upload custom Already Requested Metadata Excel:</label>
                    <input type="file" id="already-requested-file" accept=".xlsx,.xls" @change="loadAlreadyRequestedMetadata($event)">
                </div>
            </div>
        </div>
        
        <div>
            <h2>Step 2: Enter Field Names</h2>
            <p>Enter one field name per line:</p>
            <textarea id="field-names" value="id&#10;name&#10;score" placeholder="id&#10;name&#10;credit_score" x-model="fieldNamesText"></textarea>
            <div class="buttons">
                <button @click="processFields()">Process Fields</button>
            </div>
        </div>
        
        <div id="results-section" x-show="showResults">
            <h2>Results</h2>
            <table id="results-table">
                <thead>
                    <tr>
                        <th>Source</th>
                        <th>Source Field</th>
                        <th>Field Name</th>
                        <th>Business Description</th>
                        <th>Classification</th>
                        <th>PI</th>
                        <th>PCI</th>
                        <th>Treatment</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="results-body">
                    <template x-for="(result, index) in results" :key="index">
                        <tr :data-field-name="result.fieldName">
                            <td>
                                <template x-if="result.noMatch">
                                    <span>-</span>
                                </template>
                                <template x-if="!result.noMatch">
                                    <span x-text="result.currentField.source"></span>
                                </template>
                            </td>
                            <td>
                                <template x-if="result.noMatch">
                                    <span>-</span>
                                </template>
                                <template x-if="!result.noMatch">
                                    <span x-text="result.currentField.name"></span>
                                </template>
                            </td>
                            <td x-text="result.fieldName"></td>
                            <td>
                                <template x-if="result.noMatch">
                                    <span>-</span>
                                </template>
                                <template x-if="!result.noMatch">
                                    <div class="tooltip-container">
                                        <span x-text="truncateDescription(result.currentField.business_description, 50)"></span>
                                        <span class="tooltip" x-show="result.currentField.business_description && result.currentField.business_description.length > 50" x-text="result.currentField.business_description"></span>
                                    </div>
                                </template>
                            </td>
                            <td x-text="result.noMatch ? 'No matching field found' : result.currentField.classification" :colspan="result.noMatch ? 4 : 1"></td>
                            <td x-text="result.noMatch ? '' : (result.currentField.pi === true ? 'Yes' : 'No')" x-show="!result.noMatch"></td>
                            <td x-text="result.noMatch ? '' : (result.currentField.pci === true ? 'Yes' : 'No')" x-show="!result.noMatch"></td>
                            <td x-text="result.noMatch ? '' : result.currentField.treatment" x-show="!result.noMatch"></td>
                            <td>
                                <div class="action-buttons">
                                    <button @click="setAutoMode(index)" :class="{ 'active': result.mode === 'auto' }">Auto</button>
                                    <button @click="openSearch(index)" :class="{ 'active': result.mode === 'manual' }">Search</button>
                                </div>
                            </td>
                        </tr>
                    </template>
                </tbody>
            </table>
            <div class="buttons">
                <button @click="exportResults()">Export Results</button>
                <button @click="copyAsTable()">Copy as Table</button>
            </div>
        </div>
        
        <!-- Search Modal -->
        <div class="modal" x-show="showSearchModal" @click.self="closeSearch()">
            <div class="modal-content">
                <h3>Search Fields</h3>
                <div class="search-filters">
                    <input type="text" placeholder="Field name (min 2 chars)" x-model="searchFieldName" @input="updateSearchResults()">
                    <input type="text" placeholder="Source (min 4 chars)" x-model="searchSource" @input="updateSearchResults()">
                    <select x-model="searchLimit" @change="updateSearchResults()">
                        <option value="20">Limit: 20</option>
                        <option value="100">Limit: 100</option>
                        <option value="1000">Limit: 1000</option>
                    </select>
                </div>
                <div class="search-results">
                    <template x-if="!canSearch">
                        <div class="search-message">Enter at least 2 characters in Field name or 4 characters in Source to search</div>
                    </template>
                    <template x-if="canSearch && filteredSearchResults.length === 0">
                        <div class="search-message">No matching fields found</div>
                    </template>
                    <template x-if="filteredSearchResults.length > 0">
                        <table>
                            <thead>
                                <tr>
                                    <th>Source</th>
                                    <th>Field Name</th>
                                    <th>Business Description</th>
                                    <th>Classification</th>
                                    <th>PI</th>
                                    <th>PCI</th>
                                    <th>Treatment</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="(field, index) in filteredSearchResults" :key="index">
                                    <tr>
                                        <td x-text="field.source"></td>
                                        <td x-text="field.name"></td>
                                        <td>
                                            <div class="tooltip-container">
                                                <span x-text="truncateDescription(field.business_description, 50)"></span>
                                                <span class="tooltip" x-show="field.business_description && field.business_description.length > 50" x-text="field.business_description"></span>
                                            </div>
                                        </td>
                                        <td x-text="field.classification"></td>
                                        <td x-text="field.pi === true ? 'Yes' : 'No'"></td>
                                        <td x-text="field.pci === true ? 'Yes' : 'No'"></td>
                                        <td x-text="field.treatment"></td>
                                        <td>
                                            <button @click="selectField(field)">Select</button>
                                        </td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </template>
                </div>
                <div class="buttons" style="margin-top: 15px;">
                    <button @click="closeSearch()">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        function app() {
            return {
                metadataData: [],
                alreadyRequestedData: [],
                fieldNamesText: '',
                results: [],
                showResults: false,
                showSearchModal: false,
                searchFieldName: '',
                searchSource: '',
                searchLimit: '20',
                currentSearchIndex: null,
                filteredSearchResults: [],
                metadataStatus: '',
                alreadyRequestedStatus: '',
                originalResults: [], // Store original auto-detected results
                
                get canSearch() {
                    return this.searchFieldName.length >= 2 || this.searchSource.length >= 4;
                },
                
                init() {
                    // Load default metadata files on page load
                    // this.loadDefaultMetadata();
                    // this.loadDefaultAlreadyRequestedMetadata();
                },
                
                loadDefaultMetadata() {
                    this.metadataStatus = 'Loading...';
                    fetch('src/metadata.xlsx')
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Network response was not ok');
                            }
                            return response.arrayBuffer();
                        })
                        .then(buffer => {
                            const data = new Uint8Array(buffer);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const worksheet = workbook.Sheets['metadata'];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet);
                            this.metadataData = this.mapMetadataToInternalSchema(jsonData);
                            this.metadataStatus = 'Default metadata loaded successfully!';
                        })
                        .catch(error => {
                            console.error('Error loading default metadata:', error);
                            this.metadataStatus = 'Error loading default metadata. Please upload manually.';
                        });
                },
                
                loadDefaultAlreadyRequestedMetadata() {
                    this.alreadyRequestedStatus = 'Loading...';
                    fetch('src/already_requested_metadata.xlsx')
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Network response was not ok');
                            }
                            return response.arrayBuffer();
                        })
                        .then(buffer => {
                            const data = new Uint8Array(buffer);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const worksheet = workbook.Sheets['ADIDO Metadata'];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet);
                            this.alreadyRequestedData = this.mapAlreadyRequestedToInternalSchema(jsonData);
                            this.alreadyRequestedStatus = 'Default already requested metadata loaded successfully!';
                        })
                        .catch(error => {
                            console.error('Error loading default already requested metadata:', error);
                            this.alreadyRequestedStatus = 'Error loading default already requested metadata. Please upload manually.';
                        });
                },
                
                loadMetadata(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const worksheet = workbook.Sheets['metadata'];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet);
                        this.metadataData = this.mapMetadataToInternalSchema(jsonData);
                        this.metadataStatus = 'Custom metadata loaded successfully!';
                    };
                    reader.readAsArrayBuffer(file);
                },
                
                loadAlreadyRequestedMetadata(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const worksheet = workbook.Sheets['data'];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet);
                        this.alreadyRequestedData = this.mapAlreadyRequestedToInternalSchema(jsonData);
                        this.alreadyRequestedStatus = 'Custom already requested metadata loaded successfully!';
                    };
                    reader.readAsArrayBuffer(file);
                },
                
                // Map metadata Excel data to internal schema
                mapMetadataToInternalSchema(data) {
                    console.log('Raw metadata data:', data);
                    return data.map(item => {
                        // Extract table path from the path field
                        let tablePath = '';
                        let tableName = 'Unknown Table';
                        
                        if (item.table_path) {
                            const pathParts = item.table_path.split('/');
                            if (pathParts.length >= 2) {
                                tablePath = pathParts.slice(0, -1).join('/');
                                tableName = pathParts[pathParts.length - 2] || 'Unknown Table';
                            }
                        }
                        
                        // Convert PI and PCI to boolean values if they're strings
                        const pi = typeof item['PI'] === 'string' ? 
                            (item['PI'].toLowerCase() === 'true' || item['PI'] === '1' || item['PI'].toLowerCase() === 'yes') : 
                            Boolean(item['PI']);
                            
                        const pci = typeof item['PCI-DSS'] === 'string' ? 
                            (item['PCI-DSS'].toLowerCase() === 'true' || item['PCI-DSS'] === '1' || item['PCI-DSS'].toLowerCase() === 'yes') : 
                            Boolean(item['PCI-DSS']);
                        
                        return {
                            object_type: item['Object Type'] || '',
                            field_name: item['Name'] || '',
                            business_description: item['Business Description'] || '',
                            classification: item['Security Classification'] || '',
                            pi: pi,
                            pci: pci,
                            treatment: item['Data Treatment'] || '',
                            path: item.path || '',
                            table_path: tablePath,
                            table_name: tableName
                        };
                    });
                },
                
                // Map already requested metadata Excel data to internal schema
                mapAlreadyRequestedToInternalSchema(data) {
                    console.log('Raw already requested data:', data);
                    return data.map(item => {
                        // Convert PI and PCI to boolean values if they're strings
                        const pi = typeof item['PI'] === 'string' ? 
                            (item['PI'].toLowerCase() === 'true' || item['PI'] === '1' || item['PI'].toLowerCase() === 'yes') : 
                            Boolean(item['PI']);
                            
                        const pci = typeof item['PCI'] === 'string' ? 
                            (item['PCI'].toLowerCase() === 'true' || item['PCI'] === '1' || item['PCI'].toLowerCase() === 'yes') : 
                            Boolean(item['PCI']);
                        
                        return {
                            report_file: item['File Name'] || '',
                            field_name: item['Field Name'] || '',
                            business_description: item['Business Description'] || '',
                            classification: item['Classification'] || '',
                            pi: pi,
                            pci: pci,
                            treatment: item['Data Treatment'] || '',
                        };
                    });
                },
                
                processFields() {
                    if (this.metadataData.length === 0 && this.alreadyRequestedData.length === 0) {
                        alert('Please load at least one metadata file first!');
                        return;
                    }
                    
                    const fieldNames = this.fieldNamesText.split('\n').filter(name => name.trim() !== '');
                    
                    if (fieldNames.length === 0) {
                        alert('Please enter at least one field name!');
                        return;
                    }
                    
                    this.results = fieldNames.map(fieldName => {
                        // First check in already requested data (higher priority)
                        const alreadyRequestedMatches = this.alreadyRequestedData.filter(item => 
                            item.field_name.toLowerCase() === fieldName.trim().toLowerCase()
                        );
                        
                        if (alreadyRequestedMatches.length > 0) {
                            // Add source information
                            const enhancedMatches = alreadyRequestedMatches.map(match => {
                                return {
                                    source: match.report_file || 'Unknown Report',
                                    name: match.field_name,
                                    business_description: match.business_description || '',
                                    classification: match.classification || '',
                                    pi: match.pi,
                                    pci: match.pci,
                                    treatment: match.treatment || '',
                                    table_path: '',
                                    from_source: 'already_requested'
                                };
                            });
                            
                            return {
                                fieldName,
                                noMatch: false,
                                matchingFields: enhancedMatches,
                                currentField: enhancedMatches[0],
                                mode: 'auto'
                            };
                        }
                        
                        // Then check in metadata
                        const metadataMatches = this.metadataData.filter(item => 
                            item.object_type === 'field' && item.field_name.toLowerCase() === fieldName.trim().toLowerCase()
                        );
                        
                        if (metadataMatches.length > 0) {
                            // Add source information
                            const enhancedMatches = metadataMatches.map(match => {
                                return {
                                    source: match.table_name || 'Unknown Table',
                                    name: match.field_name,
                                    business_description: match.business_description || '',
                                    classification: match.classification || '',
                                    pi: match.pi,
                                    pci: match.pci,
                                    treatment: match.treatment || '',
                                    table_path: match.table_path || '',
                                    from_source: 'metadata'
                                };
                            });
                            
                            return {
                                fieldName,
                                noMatch: false,
                                matchingFields: enhancedMatches,
                                currentField: enhancedMatches[0],
                                mode: 'auto'
                            };
                        }
                        
                        // No match found
                        return {
                            fieldName,
                            noMatch: true,
                            mode: 'auto'
                        };
                    });
                    
                    // Store a deep copy of the original results for Auto mode
                    this.originalResults = JSON.parse(JSON.stringify(this.results));
                    
                    this.showResults = true;
                },
                
                updateSearchResults() {
                    if (!this.canSearch) {
                        this.filteredSearchResults = [];
                        return;
                    }
                    
                    // Combine both data sources
                    const allFields = [
                        ...this.alreadyRequestedData.map(item => {
                            return {
                                source: item.report_file || 'Unknown Report',
                                name: item.field_name,
                                business_description: item.business_description || '',
                                classification: item.classification || '',
                                pi: item.pi,
                                pci: item.pci,
                                treatment: item.treatment || '',
                                table_path: '',
                                from_source: 'already_requested'
                            };
                        }),
                        ...this.metadataData.filter(item => item.object_type === 'field').map(item => {
                            return {
                                source: item.table_name || 'Unknown Table',
                                name: item.field_name,
                                business_description: item.business_description || '',
                                classification: item.classification || '',
                                pi: item.pi,
                                pci: item.pci,
                                treatment: item.treatment || '',
                                table_path: item.table_path || '',
                                from_source: 'metadata'
                            };
                        })
                    ];
                    
                    // Apply filters
                    this.filteredSearchResults = allFields.filter(field => {
                        const nameMatch = this.searchFieldName.length < 2 || 
                            field.name.toLowerCase().includes(this.searchFieldName.toLowerCase());
                        const sourceMatch = this.searchSource.length < 4 || 
                            field.source.toLowerCase().includes(this.searchSource.toLowerCase());
                        return nameMatch && sourceMatch;
                    }).slice(0, parseInt(this.searchLimit)); // Apply limit
                },
                
                setAutoMode(index) {
                    // Restore the original auto-detected result
                    if (this.originalResults[index]) {
                        this.results[index] = JSON.parse(JSON.stringify(this.originalResults[index]));
                        this.results[index].mode = 'auto';
                    }
                },
                
                openSearch(index) {
                    this.currentSearchIndex = index;
                    this.searchFieldName = this.results[index].fieldName;
                    this.searchSource = '';
                    this.searchLimit = '20';
                    this.showSearchModal = true;
                    this.updateSearchResults();
                },
                
                closeSearch() {
                    this.showSearchModal = false;
                    this.currentSearchIndex = null;
                    this.searchFieldName = '';
                    this.searchSource = '';
                    this.filteredSearchResults = [];
                },
                
                selectField(field) {
                    if (this.currentSearchIndex !== null) {
                        this.results[this.currentSearchIndex].noMatch = false;
                        this.results[this.currentSearchIndex].currentField = field;
                        this.results[this.currentSearchIndex].mode = 'manual';
                        this.closeSearch();
                    }
                },
                
                exportResults() {
                    if (this.results.length === 0) {
                        alert('No results to export!');
                        return;
                    }
                    
                    let csvContent = 'object_type,name,table_path,business_description,classification,pi,pci,treatment\n';
                    
                    this.results.forEach(result => {
                        if (result.noMatch) return;
                        
                        // Escape any commas in the business description
                        const escapedDescription = result.currentField.business_description ? 
                            `"${result.currentField.business_description.replace(/"/g, '""')}"` : '';
                        
                        // Use the original field name for export, but keep all other data from the selected field
                        const tablePath = result.currentField.table_path || '';
                        csvContent += `field,${result.fieldName},${tablePath},${escapedDescription},${result.currentField.classification},${result.currentField.pi},${result.currentField.pci},${result.currentField.treatment}\n`;
                    });
                    
                    this.downloadCSV(csvContent, 'classified_fields.csv');
                },
                
                copyAsTable() {
                    if (this.results.length === 0) {
                        alert('No results to copy!');
                        return;
                    }
                    
                    // Create a table with the specified columns
                    let tableContent = 'Field Name\tBusiness Description\tClassification\tPI\tPCI\tTreatment\n';
                    
                    // Add each row
                    this.results.forEach(result => {
                        if (result.noMatch) {
                            tableContent += `${result.fieldName}\t\tNo matching field found\t\t\t\n`;
                        } else {
                            tableContent += `${result.fieldName}\t${result.currentField.business_description || ''}\t${result.currentField.classification || ''}\t${result.currentField.pi === true ? 'Yes' : 'No'}\t${result.currentField.pci === true ? 'Yes' : 'No'}\t${result.currentField.treatment || ''}\n`;
                        }
                    });
                    
                    // Copy to clipboard
                    this.copyToClipboard(tableContent);
                    alert('Table copied to clipboard!');
                },
                
                copyToClipboard(text) {
                    // Create a temporary textarea element
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    document.body.appendChild(textarea);
                    
                    // Select and copy the text
                    textarea.select();
                    document.execCommand('copy');
                    
                    // Remove the temporary element
                    document.body.removeChild(textarea);
                },
                
                downloadCSV(content, filename) {
                    const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    
                    const link = document.createElement('a');
                    link.setAttribute('href', url);
                    link.setAttribute('download', filename);
                    link.style.visibility = 'hidden';
                    
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },
                
                // Helper function to truncate text and preserve line breaks for display
                truncateDescription(text, maxLength = 50) {
                    if (!text) return '';
                    
                    // Replace line breaks with a visible character for display
                    const displayText = text.length > maxLength ? 
                        text.substring(0, maxLength) + '...' : 
                        text;
                        
                    return displayText;
                }
            };
        }
    </script>
</body>
</html>
