<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Extraction Field Classifier</title>
    <!-- Alpine.js for state management -->
    <script src="https://unpkg.com/alpinejs@3.13.0/dist/cdn.min.js" defer></script>
    <!-- XLSX-Populate for Excel file handling -->
    <script src="https://unpkg.com/xlsx-populate@1.21.0/browser/xlsx-populate.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@1.5.10/css/pico.min.css">
    <style>
        /* Scale down the entire UI */
        :root {
            font-size: 14px; /* Reduced from default 16px */
        }

        /* Dark mode styles */
        [data-theme="dark"] {
            --background-color: #2480c5;
            --new-background-color: #11191f;
            --color: #f2f2f2;
            --card-background-color: #1e2a36;
            --card-border-color: #374956;
            --form-element-background-color: #1e2a36;
            --form-element-border-color: #374956;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --secondary: #d64707;
            --secondary-hover: #cd5f24;
            --hover-row-color: rgba(59, 130, 246, 0.15);
        }

        /* Light mode styles */
        [data-theme="light"] {
            --background-color: #c83535;
            --new-background-color: #e8ece9;
            --color: #11191f;
            --card-background-color: #f9fafb;
            --card-border-color: #e5e7eb;
            --form-element-background-color: #ffffff;
            --form-element-border-color: #d1d5db;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --secondary: #d64707;
            --secondary-hover: #cd5f24;
            --hover-row-color: rgba(59, 130, 246, 0.1);
        }

        body {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.5;
        }

        html {
            background-color: var(--new-background-color);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        /* Card styles */
        .card {
            display: flex;
            flex-direction: column;
            background-color: var(--card-background-color);
            border: 1px solid var(--card-border-color);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .card h2 {
            margin-top: 0;
            margin-bottom: 0.5rem;
            font-size: 1.25rem;
        }

        .info-box {
            background-color: rgba(59, 130, 246, 0.1);
            border-left: 3px solid var(--primary);
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            border-radius: 0.25rem;
        }

        /* Grid layout */
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .full-width-card {
            grid-column: 1 / -1;
        }

        /* Button and form adjustments */
        .buttons {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        button {
            margin: 0;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }

        /* Reduce size of form elements */
        input, select, button {
            padding: 0.5rem 0.75rem;
            font-size: 0.9rem;
        }

        /* Table adjustments */
        table {
            font-size: 0.9rem;
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 0.5rem 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--card-border-color);
        }

        th {
            font-size: 0.85rem; /* Reduce header size by ~20% */
        }

        /* Add styles for theme switcher */
        .theme-switcher {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background-color: var(--card-background-color);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: transform 0.8s ease;
        }

        .theme-switcher:hover {
            transform: rotate(30deg);
        }

        .theme-switcher svg {
            width: 1.5rem;
            height: 1.5rem;
            fill: none;
            stroke: var(--color);
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* Status messages */
        .status-message {
            margin-top: 0.75rem;
            padding: 0.75rem;
            border-radius: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .status-message.loading {
            background-color: rgba(59, 130, 246, 0.1);
            border-left: 3px solid var(--primary);
        }

        .status-message.error {
            background-color: rgba(239, 68, 68, 0.1);
            border-left: 3px solid #ef4444;
            color: #ef4444;
        }

        .info-box.success {
            background-color: rgba(34, 197, 94, 0.1);
            border-left: 3px solid #22c55e;
        }

        /* Loading spinner */
        .spinner {
            width: 1.25rem;
            height: 1.25rem;
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .file-input-row {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
            flex-wrap: nowrap;
            width: 100%;
        }

        .file-input-row label {
            white-space: nowrap;
            flex: 0 0 auto;
            min-width: 150px;
        }

        .file-input-row input[type="file"] {
            flex: 1 1 auto;
            min-width: 0;
        }

        .file-inputs {
            margin-bottom: 1rem;
        }

        /* Adhoc file list styles */
        .adhoc-file-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 1rem;
        }

        .adhoc-file-list tr {
            cursor: pointer;
        }

        .adhoc-file-list tr:hover {
            background-color: var(--hover-row-color);
        }

        .adhoc-file-list tr.selected-row {
            background-color: var(--hover-row-color);
        }

        .export-button {
            background-color: var(--primary);
            color: white;
        }

        .export-button:hover {
            background-color: var(--primary-hover);
        }

        /* Table column width adjustments */
        .adhoc-file-list table th:first-child,
        .adhoc-file-list table td:first-child {
            width: 1%; /* Minimal width for Selection column */
            white-space: nowrap;
        }
        
        .adhoc-file-list table th:nth-child(2),
        .adhoc-file-list table td:nth-child(2) {
            width: 15%; /* Small width for Source column */
            white-space: nowrap;
        }
        
        .adhoc-file-list table th:nth-child(3),
        .adhoc-file-list table td:nth-child(3) {
            width: auto; /* File Name takes remaining space */
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: var(--card-background-color);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            border-bottom: 1px solid var(--card-border-color);
        }

        .modal-body {
            padding: 1rem;
        }

        .modal-footer {
            padding: 1rem;
            border-top: 1px solid var(--card-border-color);
            display: flex;
            justify-content: flex-end;
        }

        .close-button {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--color);
        }

        .warning-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .warning-table th, .warning-table td {
            padding: 0.5rem;
            text-align: left;
            border: 1px solid var(--card-border-color);
        }

        .warning-table th {
            background-color: rgba(59, 130, 246, 0.1);
        }
    </style>
</head>
<body x-data="{ ...app(), theme: 'dark' }" x-init="initTheme()" :data-theme="theme">
<!-- Theme Switcher -->
<div class="theme-switcher" @click="toggleTheme()">
    <!-- Sun icon for light mode -->
    <svg x-show="theme === 'light'" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <circle cx="12" cy="12" r="5"></circle>
        <line x1="12" y1="1" x2="12" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="23"></line>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
        <line x1="1" y1="12" x2="3" y2="12"></line>
        <line x1="21" y1="12" x2="23" y2="12"></line>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
    <!-- Moon icon for dark mode -->
    <svg x-show="theme === 'dark'" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
</div>

<div class="container">
    <h1 style="margin-bottom: 24px;">Data Extraction Field Classifier</h1>

    <!-- Steps Grid -->
    <div class="grid">
        <!-- Step 1 Card -->
        <div class="card">
            <h2>Step 1: Load Metadata File</h2>
            <div class="info-box">
                Select an Excel (.xlsx) file containing both ADIDO Metadata and Adhoc Data sheets.
            </div>
            <div class="file-inputs">
                <div class="file-input-row">
                    <label>Browse for Excel file:</label>
                    <input type="file" id="metadata-file" accept=".xlsx,.xls" @change="loadMetadataFile($event)">
                </div>
                
                <!-- Loading message -->
                <div class="status-message loading" x-show="metadataStatus.includes('Loading')">
                    <div class="spinner"></div>
                    <span x-text="metadataStatus"></span>
                </div>
                
                <!-- Error message -->
                <div class="status-message error" x-show="metadataStatus.includes('Failed')">
                    <span x-text="metadataStatus"></span>
                </div>
                
                <!-- Success message -->
                <div class="info-box success" x-show="metadataStatus.includes('successfully')">
                    <span>✓ ADIDO Metadata sheet loaded: <span x-text="adidoMetadataCount"></span> records</span>
                    <template x-if="adhocDataCount > 0">
                        <span><br/>✓ Adhoc Data sheets loaded: <span x-text="adhocDataCount"></span> records</span>
                    </template>
                </div>
            </div>
        </div>

        <!-- Step 2 Card -->
        <div class="card">
            <h2>Step 2</h2>
            <div class="info-box">
                Load ADIDO Metadata Template files.
            </div>
            <div class="file-inputs">
                <div class="file-input-row">
                    <label>Browse for ADIDO Template:</label>
                    <input type="file" id="adido-template-file" accept=".xlsx,.xls" @change="loadADIDOTemplateFile($event)">
                </div>
                
                <!-- Loading message -->
                <div class="status-message loading" x-show="templateStatus.includes('Loading')">
                    <div class="spinner"></div>
                    <span x-text="templateStatus"></span>
                </div>
                
                <!-- Error message -->
                <div class="status-message error" x-show="templateStatus.includes('Failed')">
                    <span x-text="templateStatus"></span>
                </div>
                
                <!-- Success message -->
                <div class="info-box success" x-show="templateStatus.includes('successfully')">
                    <span>✓ ADIDO Template loaded successfully</span>
                </div>
            </div>
        </div>

        <!-- Step 3 Card -->
        <div class="card full-width-card">
            <h2>Step 3</h2>
            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 1.5rem;">
                <!-- Left Column -->
                <div>
                    <!-- Top Row with Info Box and Filter -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <div class="info-box" style="margin-bottom: 0; flex: 1;">
                            Select files to generate ADIDO template
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-left: 1rem;">
                            <label for="file-filter">Filter file name:</label>
                            <input type="text" id="file-filter" placeholder="Min 2 characters" x-model="fileFilter" @input="filterAdhocFiles()">
                        </div>
                    </div>
                    
                    <!-- Selection Table -->
                    <div class="adhoc-file-list">
                        <table>
                            <thead>
                                <tr>
                                    <th style="width: 1%;"></th>
                                    <th style="width: 15%;">Source</th>
                                    <th>File Name</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="(item, index) in filteredAdhocData" :key="index">
                                    <tr @click="toggleFileSelection(item.file_name)" :class="{ 'selected-row': isFileSelected(item.file_name) }">
                                        <td style="width: 1%;">
                                            <input type="checkbox" :checked="isFileSelected(item.file_name)" @click.stop="toggleFileSelection(item.file_name)">
                                        </td>
                                        <td style="width: 15%;" x-text="item.data_source === 'data_in' ? 'Data In' : 'Data Out'"></td>
                                        <td x-text="item.file_name"></td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Right Column -->
                <div>
                    <!-- Info Box with Selected Count -->
                    <div class="info-box" style="margin-bottom: 1rem;">
                        Selected Files: <span x-text="selectedAdhocFiles.length"></span>
                    </div>
                    
                    <!-- Selected Files Table -->
                    <div class="adhoc-file-list">
                        <table>
                            <thead>
                                <tr>
                                    <th>File Name</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="(fileName, index) in selectedAdhocFiles" :key="index">
                                    <tr @click="toggleFileSelection(fileName)">
                                        <td x-text="fileName"></td>
                                    </tr>
                                </template>
                                <tr x-show="selectedAdhocFiles.length === 0">
                                    <td style="text-align: center; color: var(--muted-color);">No files selected</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <!-- Submit Button Row -->
            <div style="display: flex; justify-content: center; margin-top: 1.5rem;">
                <button @click="generateADIDOTemplate()" class="export-button" :disabled="adhocDataCount === 0 || selectedAdhocFiles.length === 0" style="width: auto;">
                    Generate ADIDO template
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Warning Modal -->
<div class="modal" x-show="showWarningModal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Data Validation Warnings</h3>
            <button @click="showWarningModal = false" class="close-button">&times;</button>
        </div>
        <div class="modal-body">
            <p>The following issues were found in your data:</p>
            <table class="warning-table">
                <thead>
                    <tr>
                        <th>Warning</th>
                        <th>Details</th>
                    </tr>
                </thead>
                <tbody>
                    <template x-for="(warning, index) in validationWarnings" :key="index">
                        <tr>
                            <td x-text="warning.message"></td>
                            <td x-text="warning.details"></td>
                        </tr>
                    </template>
                </tbody>
            </table>
        </div>
        <div class="modal-footer">
            <button @click="showWarningModal = false">Close</button>
        </div>
    </div>
</div>

<script>
    function app() {
        return {
            adidoMetadata: [],
            adhocData: [],
            filteredAdhocData: [],
            metadataStatus: '',
            templateStatus: '',
            adidoMetadataCount: 0,
            adhocDataCount: 0,
            selectedAdhocFiles: [],
            templateData: null,
            fileFilter: '',
            showWarningModal: false,
            validationWarnings: [],
            validClassifications: ['Critical', 'Restricted', 'Confidential', 'Internal', 'Public'],
            
            // Adhoc data column mapping
            adhocDataMapping: {
                "Status": "status",
                "Team Requesting": "team_requesting",
                "Sub-Team requesting": "sub_team_requesting",
                "Also requested by other LOB?": "also_requested_by_other_lob",
                "New/Existing Initiative": "initiative_status",
                "File Name": "file_name",
                "Data Out Purpose": "data_out_purpose",
                "Type of Data Out": "data_out_type",
                "Frequency": "frequency",
                "Process Name": "process_name",
                "Recipient": "recipient",
                "Recipient Name": "recipient_name",
                "Contain PII?": "contains_pii",
                "If External - Please specify 3rd party": "external_third_party",
                "is the Recipient from another AZ": "recipient_from_another_az",
                "Will it be used in Use-cases?": "used_in_usecases",
                "Usecase SME": "usecase_sme",
                "Impact": "impact",
                "File Type": "file_type",
                "Retention Code": "retention_code",
                "Retention Period": "retention_period",
                "Impacted Jurisdiction Country": "jurisdiction_country",
                "Impacted Jurisdiction Province": "jurisdiction_province"
            },

            // Theme functions
            initTheme() {
                // Check for saved theme preference or use default (dark)
                const savedTheme = localStorage.getItem('theme') || 'dark';
                this.theme = savedTheme;
                document.documentElement.setAttribute('data-theme', savedTheme);
            },
            
            toggleTheme() {
                // Toggle between light and dark themes
                const newTheme = this.theme === 'light' ? 'dark' : 'light';
                this.theme = newTheme;
                localStorage.setItem('theme', newTheme);
                document.documentElement.setAttribute('data-theme', newTheme);
            },
            
            closeWindow() {
                window.close();
            },

            // File loading functions
            loadMetadataFile(event) {
                const file = event.target.files[0];
                if (!file) return;

                this.metadataStatus = 'Loading metadata file... Please wait.';

                const reader = new FileReader();
                reader.onload = (e) => {
                    this.processExcelFile(e.target.result);
                };
                reader.onerror = () => {
                    this.metadataStatus = 'Failed to read file. Please try again.';
                };
                reader.readAsArrayBuffer(file);
            },

            loadADIDOTemplateFile(event) {
                const file = event.target.files[0];
                if (!file) return;

                this.templateStatus = 'Loading ADIDO template file... Please wait.';

                const reader = new FileReader();
                reader.onload = (e) => {
                    this.processTemplateFile(e.target.result);
                };
                reader.onerror = () => {
                    this.templateStatus = 'Failed to read template file. Please try again.';
                };
                reader.readAsArrayBuffer(file);
            },

            processTemplateFile(buffer) {
                try {
                    // Load the template with XLSX-Populate to preserve formatting
                    XlsxPopulate.fromDataAsync(buffer)
                        .then(workbook => {
                            this.templateData = workbook;
                            this.templateStatus = 'ADIDO template loaded successfully!';
                        })
                        .catch(error => {
                            console.error('Error processing template file:', error);
                            this.templateStatus = `Failed to process template file: ${error.message}`;
                        });
                } catch (error) {
                    console.error('Error processing template file:', error);
                    this.templateStatus = `Failed to process template file: ${error.message}`;
                }
            },

            processExcelFile(buffer) {
                try {
                    // Use XLSX-Populate to read the Excel file
                    XlsxPopulate.fromDataAsync(buffer)
                        .then(workbook => {
                            // Check if ADIDO Metadata sheet exists
                            if (!workbook.sheet('ADIDO Metadata')) {
                                throw new Error('Excel file must contain "ADIDO Metadata" sheet');
                            }

                            // Process ADIDO Metadata sheet
                            const adidoSheet = workbook.sheet('ADIDO Metadata');
                            const adidoJsonData = this.sheetToJson(adidoSheet);
                            this.adidoMetadata = this.mapAdidoMetadataToInternalSchema(adidoJsonData);
                            this.adidoMetadataCount = this.adidoMetadata.length;

                            // Process Adhoc Data-In sheet if it exists
                            this.adhocData = [];
                            if (workbook.sheet('Adhoc Data-In')) {
                                const adhocInSheet = workbook.sheet('Adhoc Data-In');
                                const adhocInJsonData = this.sheetToJson(adhocInSheet);
                                const mappedInData = this.mapAdhocDataToInternalSchema(adhocInJsonData, 'data_in');
                                this.adhocData = [...this.adhocData, ...mappedInData];
                            }
                            
                            // Process Adhoc Data-Out sheet if it exists
                            if (workbook.sheet('Adhoc Data-Out')) {
                                const adhocOutSheet = workbook.sheet('Adhoc Data-Out');
                                const adhocOutJsonData = this.sheetToJson(adhocOutSheet);
                                const mappedOutData = this.mapAdhocDataToInternalSchema(adhocOutJsonData, 'data_out');
                                this.adhocData = [...this.adhocData, ...mappedOutData];
                            }
                            
                            this.adhocDataCount = this.adhocData.length;
                            this.filteredAdhocData = [...this.adhocData]; // Initialize filtered data
                            this.metadataStatus = 'Metadata loaded successfully!';
                            
                            // Show warnings if any were found
                            if (this.validationWarnings.length > 0) {
                                this.showWarningModal = true;
                            }
                        })
                        .catch(error => {
                            console.error('Error processing Excel file:', error);
                            this.metadataStatus = `Failed to process Excel file: ${error.message}`;
                        });
                } catch (error) {
                    console.error('Error processing Excel file:', error);
                    this.metadataStatus = `Failed to process Excel file: ${error.message}`;
                }
            },
            
            mapAdidoMetadataToInternalSchema(data) {
                this.validationWarnings = []; // Reset warnings
                
                return data.map(item => {
                    // Validate PI value
                    const validPiValues = ['yes', 'no', 'true', 'false', '1', '0'];
                    const piValue = item['PI']?.toString().toLowerCase();
                    if (item['PI'] !== undefined && item['PI'] !== null && !validPiValues.includes(piValue)) {
                        this.validationWarnings.push({
                            message: `Unexpected PI value (${item['PI']})`,
                            details: `Report: ${item['File Name']}, Field: ${item['Field Name']}`
                        });
                    }
                    
                    // Validate PCI value
                    const pciValue = item['PCI']?.toString().toLowerCase();
                    if (item['PCI'] !== undefined && item['PCI'] !== null && !validPiValues.includes(pciValue)) {
                        this.validationWarnings.push({
                            message: `Unexpected PCI value (${item['PCI']})`,
                            details: `Report: ${item['File Name']}, Field: ${item['Field Name']}`
                        });
                    }
                    console.log(`File: ${item['File Name']}, Field: ${item['Field Name'], item['PI'], item['PCI'], item['Classification']}`);
                    // Validate Classification value
                    if (item['Classification'] && !this.validClassifications.includes(item['Classification'])) {
                        this.validationWarnings.push({
                            message: `Invalid Classification (${item['Classification']})`,
                            details: `Report: ${item['File Name']}, Field: ${item['Field Name']}`
                        });
                    }
                    
                    // Convert PI and PCI to boolean values
                    const pi = typeof item['PI'] === 'string' 
                        ? ['yes', 'true', '1'].includes(item['PI'].toLowerCase()) 
                        : Boolean(item['PI']);
                        
                    const pci = typeof item['PCI'] === 'string' 
                        ? ['yes', 'true', '1'].includes(item['PCI'].toLowerCase()) 
                        : Boolean(item['PCI']);

                    return {
                        report_file: item['File Name'] || '',
                        field_name: item['Field Name'] || '',
                        business_description: item['Business Description'] || '',
                        classification: item['Classification'] || '',
                        pi: pi,
                        pci: pci,
                        treatment: item['Data Treatment'] || ''
                    };
                });
            },
            
            mapAdhocDataToInternalSchema(data, dataSource) {
                return data.map(item => {
                    const mappedItem = { data_source: dataSource };
                    
                    // Map each column using the mapping object
                    Object.keys(this.adhocDataMapping).forEach(key => {
                        const internalKey = this.adhocDataMapping[key];
                        mappedItem[internalKey] = item[key] || '';
                    });
                    
                    return mappedItem;
                });
            },
            
            toggleFileSelection(fileName) {
                if (this.isFileSelected(fileName)) {
                    this.selectedAdhocFiles = this.selectedAdhocFiles.filter(f => f !== fileName);
                } else {
                    this.selectedAdhocFiles.push(fileName);
                }
            },
            
            isFileSelected(fileName) {
                return this.selectedAdhocFiles.includes(fileName);
            },
            
            generateADIDOTemplate() {
                if (!this.templateData) {
                    alert('Please load an ADIDO template file first.');
                    return;
                }
                
                if (this.selectedAdhocFiles.length === 0) {
                    alert('Please select at least one file to generate the template.');
                    return;
                }
                
                try {
                    const workbook = this.templateData;
                    
                    // Generate field metadata
                    const fieldMetadata = this.generateFieldMetadata();
                    
                    // Generate file metadata
                    const fileMetadata = this.generateFileMetadata();
                    
                    // Update Field Metadata sheet
                    const fieldSheet = workbook.sheet('Field Metadata');
                    if (fieldSheet) {
                        this.populateSheetData(fieldSheet, fieldMetadata, 'A6');
                    } else {
                        console.error('Field Metadata sheet not found in template');
                    }
                    
                    // Update File Metadata sheet
                    const fileSheet = workbook.sheet('File Metadata');
                    if (fileSheet) {
                        this.populateSheetData(fileSheet, fileMetadata, 'A4');
                    } else {
                        console.error('File Metadata sheet not found in template');
                    }
                    
                    // Generate and download the Excel file with formatting preserved
                    workbook.outputAsync()
                        .then(blob => {
                            this.saveExcelFile(blob, 'ADIDO_Template_Generated.xlsx');
                        })
                        .catch(error => {
                            console.error('Error generating Excel file:', error);
                            alert(`Failed to generate Excel file: ${error.message}`);
                        });
                    
                } catch (error) {
                    console.error('Error generating ADIDO template:', error);
                    alert(`Failed to generate ADIDO template: ${error.message}`);
                }
            },
            
            generateFieldMetadata() {
                // Filter adidoMetadata to keep only fields from selected files
                return this.adidoMetadata
                    .filter(field => this.selectedAdhocFiles.includes(field.report_file))
                    .map(field => {
                        return [
                            field.report_file,
                            field.field_name,
                            field.business_description,
                            field.classification,
                            field.pci ? 'Yes' : 'No',
                            field.pi ? 'Yes' : 'No',
                            field.treatment
                        ];
                    });
            },
            
            generateFileMetadata() {
                // Group adhoc data by file name
                const fileGroups = {};
                this.selectedAdhocFiles.forEach(fileName => {
                    const fileData = this.adhocData.find(item => item.file_name === fileName);
                    if (fileData) {
                        fileGroups[fileName] = fileData;
                    }
                });
                
                // Calculate file-level metadata
                return Object.values(fileGroups).map(file => {
                    // Get all fields for this file
                    const fileFields = this.adidoMetadata.filter(field => field.report_file === file.file_name);
                    
                    // Calculate classification (highest level)
                    const classificationOrder = ['Public', 'Internal', 'Confidential', 'Restricted', 'Critical'];
                    let highestClassification = 'Public';
                    
                    fileFields.forEach(field => {
                        const fieldClassIndex = classificationOrder.indexOf(field.classification);
                        const highestClassIndex = classificationOrder.indexOf(highestClassification);
                        
                        if (fieldClassIndex > highestClassIndex) {
                            highestClassification = field.classification;
                        }
                    });
                    
                    // Calculate PI/PCI (if any field has PI/PCI, then file has PI/PCI)
                    const hasPi = fileFields.some(field => field.pi);
                    const hasPci = fileFields.some(field => field.pci);
                    
                    // Create file metadata row
                    return [
                        file.file_name,
                        file.file_type || '',
                        file.data_source === 'data_out' ? file.data_out_purpose || '' : '',
                        highestClassification,
                        hasPci ? 'Yes' : 'No',
                        hasPi ? 'Yes' : 'No',
                        file.retention_code || '',
                        file.retention_period || '',
                        file.jurisdiction_country || '',
                        file.jurisdiction_province || '',
                        '', // delimiter (always empty)
                        ''  // line_length (always empty)
                    ];
                });
            },
            
            // Helper function to populate sheet data while preserving formatting
            populateSheetData(sheet, data, startCell) {
                // Parse the starting cell reference (e.g., 'A4' -> row 4, column 1)
                const match = startCell.match(/([A-Z]+)([0-9]+)/);
                if (!match) return;
                
                const colLetter = match[1];
                const startRow = parseInt(match[2]);
                
                // Populate data
                data.forEach((row, rowIndex) => {
                    row.forEach((value, colIndex) => {
                        // Calculate cell address (A4, B4, etc.)
                        const colAddress = String.fromCharCode(colLetter.charCodeAt(0) + colIndex);
                        const rowAddress = startRow + rowIndex;
                        const cellAddress = `${colAddress}${rowAddress}`;
                        
                        // Set cell value while preserving formatting
                        sheet.cell(cellAddress).value(value);
                    });
                });
            },
            
            saveExcelFile(blob, fileName) {
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.click();
                
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 100);
            },
            
            // Helper function to convert XLSX-Populate sheet to JSON
            sheetToJson(sheet) {
                const data = [];
                const range = sheet.usedRange();
                
                if (!range) return data;
                
                // Get the range boundaries
                const startCell = range.startCell();
                const endCell = range.endCell();
                const startRow = startCell.rowNumber();
                const endRow = endCell.rowNumber();
                const startCol = startCell.columnNumber();
                const endCol = endCell.columnNumber();
                
                // Get headers from the first row
                const headers = [];
                for (let col = startCol; col <= endCol; col++) {
                    const headerCell = sheet.cell(1, col);
                    headers.push(headerCell.value() || '');
                }
                
                // Extract data rows (starting from row 2)
                for (let row = 2; row <= endRow; row++) {
                    const rowData = {};
                    let hasData = false;
                    
                    for (let col = startCol; col <= endCol; col++) {
                        const colIndex = col - startCol;
                        if (headers[colIndex]) {
                            const cellValue = sheet.cell(row, col).value();
                            if (cellValue !== undefined && cellValue !== null) {
                                rowData[headers[colIndex]] = cellValue;
                                hasData = true;
                            } else {
                                rowData[headers[colIndex]] = '';
                            }
                        }
                    }
                    
                    // Only add rows that have at least one non-empty cell
                    if (hasData) {
                        data.push(rowData);
                    }
                }
                
                return data;
            },
            // Filter adhoc files based on file name
            filterAdhocFiles() {
                if (this.fileFilter.length < 2) {
                    // If filter is less than 2 chars, show all files
                    this.filteredAdhocData = [...this.adhocData];
                    return;
                }
                
                const filterText = this.fileFilter.toLowerCase();
                this.filteredAdhocData = this.adhocData.filter(item => 
                    item.file_name.toLowerCase().includes(filterText)
                );
            },
        };
    }
</script>
</body>
</html>
